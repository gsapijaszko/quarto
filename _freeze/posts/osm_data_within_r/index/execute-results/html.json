{
  "hash": "1f84b63dc0c8fc41a59bebd2572eb505",
  "result": {
    "markdown": "---\ntitle: \"OSM data within R\"\ndescription: \"OpenStreetMap --- free and open geographical data from the whole world on hand. How to access it, how to work with it, and finally --- how to display it.\"\nauthor: \"Grzegorz Sapijaszko\"\ndate: \"2022-02-05\"\ncategories: [R, openstreetmap, maps]\nbibliography: ../../references.bib\nimage: map1.png\n---\n\n\n\n\n## Introduction\n\n[OpenStreetMap](https://www.openstreetmap.org) is a project which creates and distributes free geographic data for the world. Based on this data a hundreds of other products evolved, including [OSM Map](https://www.openstreetmap.org), [Nominatim](https://nominatim.org/) -- an open source geocoding service, routing services like [OSRM](http://project-osrm.org/) and [OpenRouteService](https://maps.openrouteservice.org/) among others, several maps styles, etc. For comprehensive overview you can check [OSM Wiki](https://wiki.openstreetmap.org/wiki/Use_OpenStreetMap).\n\n## Data access and download\n\nYou can download OpenStreetMap dataset is number of ways[^1], either the whole planet, a particular region, or ad hock data via [Overpass](https://overpass-turbo.eu/). Build around [Overpass API](https://wiki.openstreetmap.org/wiki/Overpass_API) it allows to filter out any feature and get the OSM data quickly. Overpass API is used in `osmdata` package [@osmdata2017] which will be used in our examples.\n\n[^1]: for details see https://wiki.openstreetmap.org/wiki/Downloading_data\n\nLet's load the library and check it's version\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(osmdata); packageVersion(\"osmdata\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nData (c) OpenStreetMap contributors, ODbL 1.0. https://www.openstreetmap.org/copyright\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] '0.1.10'\n```\n:::\n:::\n\n\nOpenStreetMap represents physical features on the Earth using tags attached to its basic data structures (its nodes, ways, and relations). Each tag describes a geographic attribute of the feature being shown by that specific node, way or relation. Those nodes, ways and relations can be translated to geographic objects like points, lines and polygons (closed lines). Relations in OSM are used to describe relationship between features, or other relations. For example Route 66[^2] in US described as relation consist of 11 other relations, which then divides to individual ways. As said, to describe the features a tagging system is used with with `key=value` pairs, where `key` corresponds to a topic, category, or type of feature (e.g., highway or name) and `value` provides detail for the key-specified feature[^3]. A few examples:\n\n[^2]: https://www.openstreetmap.org/relation/93155\n\n[^3]: For comprehensive list see https://wiki.openstreetmap.org/wiki/Map_features\n\n-   `boundary = administrative` -- for any kind of administrative boundaries from hamlet, through community, county to country\n-   `amenity = pub`\n-   `highway = residential`\n\nThe typical workflow will follow those steps:\n\n-   get bounding box of place of interest (using `getbb()` function)\n-   create a Overpass query (with `opq()`)\n    -   add interesting features to the query ( using `add_osm_feature()` or `add_osm_features()` for several objects at once)\n-   run the query and get the data\n\nIn below example we will get a boundaries of my village, roads, add few amenities and draft it on a map.\n\nFirstly, let's try to find a bounding box using `getbb()` function. This function uses Nominatim API to find the bounding box associated with place names.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLbb <- getbb(\"Lubnów, Oborniki Śląskie, Poland\", format_out = \"matrix\")\nLbb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       min      max\nx 16.86893 16.90716\ny 51.23703 51.28707\n```\n:::\n:::\n\n\nIt may happen, that the result of `getbb()` slightly differs from expectation. It might be due to misspeling the name, or due the fact, that there is several places with the same name. In such case changing the `format_out` to `data.frame` may help.[^4] Let's see how many Lubnów's are in OSM:\n\n[^4]: Instead of `matrix` or `data.frame` we can get the result of `getbb()` as `polygon` or `sf_polygon` for polygons that work with `sf` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetbb(\"Lubnów\", format_out = \"data.frame\") |>\n  select(display_name, boundingbox)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                                                         display_name\n1 Lubnów, gmina Oborniki Śląskie, powiat trzebnicki, województwo dolnośląskie, Polska\n2  Lubnów, gmina Ziębice, powiat ząbkowicki, województwo dolnośląskie, 57-223, Polska\n3       Lubnów, gmina Pokój, powiat namysłowski, województwo opolskie, 46-034, Polska\n                                     boundingbox\n1   51.237034, 51.2870702, 16.868925, 16.9071591\n2 50.4920755, 50.5240389, 16.9845096, 17.0430903\n3 50.9450812, 50.9850812, 17.8934085, 17.9334085\n```\n:::\n:::\n\n\nLet's add a bit of space around. Please remember, the OSM data is provided in EPSG:4326 coordinate system[^5] (the same used in GPS devices or by Google Maps) where latitude and longitude are given in decimal degrees, so we have to extend the bounding box with the degrees (or tenth of it) as well. We will create a simple matrix and add it to original bbox.\n\n[^5]: https://epsg.io/4326\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddM <- matrix(data = c(-0.01, -0.01, 0.01, 0.01), nrow = 2, ncol = 2)\nnewBB <- Lbb + addM\n```\n:::\n\n\nNow, we will create a Overpass query and search for highways using `\"highway\"` as a key:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhighways <- opq (newBB, timeout = 60) |> \n  add_osm_feature (key = \"highway\") |>\n  osmdata_sf()\n```\n:::\n\n\n`osmdata_sf` returns the data in `sf` format, which allows smooth integration with `sf` package. You can use `osmdata_sp()` for `sp` format, `osmdata_sc()` for silicate `sc` or `osmdata_xml()` function to get the data in XML format. Let's grab some other data: administrative boundaries, buildings and a few amenities. We will use `add_osm_features()` function, which allows to get several features at the time. Features inserted in `features =` list are combined with logical `OR`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\notherdata <- opq(newBB, timeout = 60) |>\n  add_osm_features(\n    features = c(\n      \"\\\"boundary\\\"= \\\"administrative\\\"\",\n      \"\\\"building\\\"\",\n      \"\\\"shop\\\"\",\n      \"\\\"historic\\\"=\\\"archaeological_site\\\"\"\n    )\n  ) |>\n  osmdata_sf()\n```\n:::\n\n\n## Filtering and displaying the data\n\nAs the data is already fetched, let's show them. For visualization we can use just internal `plot()` function or any fancy package like `ggplot2` or `osmplotr` [@R-osmplotr] which is companion package to `osmdata`.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nData (c) OpenStreetMap contributors, ODbL 1.0. http://www.openstreetmap.org/copyright\n```\n:::\n:::\n\n\nThe data returned from Overpass consist of `osm_points`, `osm_lines`, `osm_polygons` and `osm_multipolygons`. First of all we have to filter out only those geometries which we will use. Starting with village boundary:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvillageBoundary <- otherdata$osm_multipolygons |>\n  filter(boundary == \"administrative\" & admin_level == 8 & name == \"Lubnów\")\n```\n:::\n\n\nThen splitting roads by its priority, as it will be drawn by lines with different attributes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsecondary <- highways$osm_lines |>\n  filter(highway %in% c(\"secondary\"))\ntertiary <- highways$osm_lines |>\n  filter(highway %in% c(\"tertiary\", \"unclassified\"))\nservice <-  highways$osm_lines |>\n  filter(highway %in% c(\"service\", \"residential\"))\ntrack <-  highways$osm_lines |>\n  filter(highway %in% c(\"track\"))\n```\n:::\n\n\nAnd finally buildings, shop(s) and archaeological sites.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuildings <- otherdata$osm_polygons |>\n  filter((!is.na(building))) |>\n  select(osm_id, geometry)\n```\n:::\n\n\nWith shops it will be a bit tricky, as they may appear as a `osm_points` and/or `osm_polygons`, where tag `shop` is assigned to `building`. We have to ascertain both sets and glue the interesting data together. Another step which will be taken is to find centroids of the polygons and convert it to point geometries, using `st_centroid()` function from `sf` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshops <- otherdata$osm_points |>\n  filter(!is.na(shop)) |>\n  select(osm_id, opening_hours, shop, geometry)\n\nshops<- rbind(shops,\n      otherdata$osm_polygons |>\n        filter(!is.na(shop)) |>\n        mutate(geometry = st_centroid(geometry)) |>\n        select(osm_id, opening_hours, shop, geometry)\n     )\nshops <- shops |>\n  filter(shop %in% c(\"convenience\", \"supermarket\"))\n```\n:::\n\n\nAnd two historical settlements in the neighborhood.\n\n\n::: {.cell}\n\n```{.r .cell-code}\narchaeological <- otherdata$osm_points |>\n  filter(historic == \"archaeological_site\") |>\n  select(osm_id, historic, geometry)\n```\n:::\n\n\nLet's build the map using `osm_basemap()` which set up the boundaries, and then adding features with `add_osm_objects()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap <- osm_basemap(bbox = newBB, bg = \"gray95\")\nmap <- add_osm_objects(map, villageBoundary, col = \"gray99\", border = \"red\", size = 1.2)\nmap <- add_osm_objects(map, secondary, size = 3, shape = 1, col = \"orange\")\nmap <- add_osm_objects(map, secondary, size = 1.2, shape = 1, col = \"darkred\")\nmap <- add_osm_objects(map, tertiary, col = \"black\", size = 0.8)\nmap <- add_osm_objects(map, service, col = \"gray40\", size = 0.4)\nmap <- add_osm_objects(map, track, col = \"gray60\", size = 0.2)\nmap <- add_osm_objects(map, buildings, col = \"brown\")\nmap <- add_osm_objects(map, shops, size = 3, col = \"darkblue\")\nmap <- add_osm_objects(map, archaeological, size = 3, col = \"darkgreen\")\nmap <- add_axes (map, colour = \"blue\", pos = c(0.02, 0.02),\n          fontsize = 4, fontface = 2, fontfamily = \"Times\")\n```\n:::\n\n\nAnd finally let's print the map:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint_osm_map(map)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n![Our first map based on OSM data](map1.png)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}